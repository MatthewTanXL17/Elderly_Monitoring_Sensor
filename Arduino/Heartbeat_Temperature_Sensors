//-------------------------------------------------------------Include Libraries------------------------------------------------------------------------
#include <Wire.h>
#include <WiFi.h>

#include <Firebase_ESP_Client.h>
#include <Adafruit_MLX90614.h>

#include "MAX30105.h"
#include "spo2_algorithm.h"
#include "heartRate.h"

#include "time.h"

//Provide the token generation process info.
#include "addons/TokenHelper.h"

//Provide the RTDB payload printing info and other helper functions.
#include "addons/RTDBHelper.h"
//------------------------------------------------------------------------------------------------------------------------------------------------------

//---------------------------------------------------------------Define Variables-----------------------------------------------------------------------
// Insert your network credentials
#define WIFI_SSID "ranitan@unifi_EXT"
#define WIFI_PASSWORD "samtan230691"

// Insert Firebase project API Key
#define API_KEY "AIzaSyCfygy6qHQTIZBdzkgnPOI6lxypVpGKCIE"

// Insert RTDB URLefine the RTDB URL */
#define DATABASE_URL "esp32-temp-reading-default-rtdb.asia-southeast1.firebasedatabase.app/"

//Define Firebase Data object
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;

// Database main path (to be updated in setup with the user UID)
String storePath;
String syncPath;

// Database child nodes
String tempPath = "/celcius";
String timePath = "/timestamp";
String bpmPath = "/BPM";
String oxygenPath = "/SpO2";

//Define the temperature sensor variable
Adafruit_MLX90614 mlx = Adafruit_MLX90614();

//Define the pulse oximetry sensor variables
MAX30105 particleSensor;

#define MAX_BRIGHTNESS 255

uint32_t irBuffer[100]; //infrared LED sensor data
uint32_t redBuffer[100];  //red LED sensor data

int32_t bufferLength; //data length
int32_t spo2; //SPO2 value
int8_t validSPO2; //indicator to show if the SPO2 calculation is valid
int32_t heartRate; //heart rate value calcualated as per Maxim's algorithm
int8_t validHeartRate; //indicator to show if the heart rate calculation is valid

byte pulseLED = 2; //onboard led on esp32 nodemcu
byte readLED = 19; //Blinks with each data read

long lastBeat = 0; //Time at which the last beat occurred

float beatsPerMinute; //stores the BPM as per custom algorithm
int beatAvg = 0, sp02Avg = 0; //stores the average BPM and SPO2
float ledBlinkFreq; //stores the frequency to blink the pulseLED

double objectCelcius;
char timeStamp[30];
FirebaseJson json;

//For getting current time
const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = 28800;
const int   daylightOffset_sec = 0;

unsigned long sendDataPrevMillis1 = 0;
unsigned long sendDataPrevMillis2 = 0;
bool signupOK = false;
//-----------------------------------------------------------------------------------------------------------------------------------------------------

// Initialize WiFi
void initWiFi() {
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connecting to WiFi ..");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print('.');
    delay(1000);
  }
  Serial.println();
  Serial.print("Connected with IP: ");
  Serial.println(WiFi.localIP());
  Serial.println();
}

void setup() {
  Serial.begin(115200);
  //Setup pulse sensor
  ledcSetup(0, 0, 8); // PWM Channel = 0, Initial PWM Frequency = 0Hz, Resolution = 8 bits
  ledcAttachPin(pulseLED, 0); //attach pulseLED pin to PWM Channel 0
  ledcWrite(0, 255); //set PWM Channel Duty Cycle to 255

  particleSensor.begin();
  //  // Initialize sensor
  //  if (!(Wire, I2C_SPEED_FAST)) //Use default I2C port, 400kHz speed
  //  {
  //    Serial.println(F("MAX30105 was not found. Please check wiring/power."));
  //    while (1);
  //  }

  /*The following parameters should be tuned to get the best readings for IR and RED LED.
    The perfect values varies depending on your power consumption required, accuracy, ambient light, sensor mounting, etc.
    Refer Maxim App Notes to understand how to change these values*/
  byte ledBrightness = 50; //Options: 0=Off to 255=50mA
  byte sampleAverage = 1; //Options: 1, 2, 4, 8, 16, 32
  byte ledMode = 2; //Options: 1 = Red only, 2 = Red + IR, 3 = Red + IR + Green
  byte sampleRate = 100; //Options: 50, 100, 200, 400, 800, 1000, 1600, 3200
  int pulseWidth = 69; //Options: 69, 118, 215, 411
  int adcRange = 4096; //Options: 2048, 4096, 8192, 16384

  particleSensor.setup(ledBrightness, sampleAverage, ledMode, sampleRate, pulseWidth, adcRange); //Configure sensor with these settings

  mlx.begin();//Initiate temperature sensor

  initWiFi();//Initiate Wi-Fi connection

  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);//Configure time to local time

  /* Assign the api key (required) */
  config.api_key = API_KEY;

  /* Assign the RTDB URL (required) */
  config.database_url = DATABASE_URL;

  /* Sign up */
  if (Firebase.signUp(&config, &auth, "", "")) {
    Serial.println("ok");
    signupOK = true;
  }
  else {
    Serial.printf("%s\n", config.signer.signupError.message.c_str());
  }

  /* Assign the callback function for the long running token generation task */
  config.token_status_callback = tokenStatusCallback; //see addons/TokenHelper.h

  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);

  //database path
  storePath = "/readings/store";
  syncPath = "/readings/sync";
}

void loop() {
  //----------------------------------heartbeat sensor functions-------------------------------------
  bufferLength = 100; //buffer length of 100 stores 4 seconds of samples running at 25sps

  //read the first 100 samples, and determine the signal range
  for (byte i = 0 ; i < bufferLength ; i++)
  {
    while (particleSensor.available() == false) //do we have new data?
      particleSensor.check(); //Check the sensor for new data

    redBuffer[i] = particleSensor.getIR();
    irBuffer[i] = particleSensor.getRed();
    particleSensor.nextSample(); //We're finished with this sample so move to next sample
  }

  //calculate heart rate and SpO2 after first 100 samples (first 4 seconds of samples)
  maxim_heart_rate_and_oxygen_saturation(irBuffer, bufferLength, redBuffer, &spo2,
                                         &validSPO2, &heartRate, &validHeartRate);

  //Continuously taking samples from MAX30102.  Heart rate and SpO2 are calculated every 1 second
  while (1)
  {
    //dumping the first 25 sets of samples in the memory and shift the last 75 sets of samples to the top
    for (byte i = 25; i < 100; i++)
    {
      redBuffer[i - 25] = redBuffer[i];
      irBuffer[i - 25] = irBuffer[i];
    }

    //take 25 sets of samples before calculating the heart rate.
    for (byte i = 75; i < 100; i++)
    {
      while (particleSensor.available() == false) //do we have new data?
        particleSensor.check(); //Check the sensor for new data

      digitalWrite(readLED, !digitalRead(readLED)); //Blink onboard LED with every data read

      redBuffer[i] = particleSensor.getRed();
      irBuffer[i] = particleSensor.getIR();
      particleSensor.nextSample(); //We're finished with this sample so move to next sample

      long irValue = irBuffer[i];

      //Calculate BPM independent of Maxim Algorithm.
      if (checkForBeat(irValue) == true)
      {
        //We sensed a beat!
        long delta = millis() - lastBeat;
        lastBeat = millis();

        beatsPerMinute = 60 / (delta / 1000.0);
        beatAvg = (beatAvg + beatsPerMinute) / 2;

        if (beatAvg != 0)
          ledBlinkFreq = (float)(60.0 / beatAvg);
        else
          ledBlinkFreq = 0;
        ledcWriteTone(0, ledBlinkFreq);
      }
      if (millis() - lastBeat > 10000)
      {
        beatsPerMinute = 0;
        beatAvg = (beatAvg + beatsPerMinute) / 2;

        if (beatAvg != 0)
          ledBlinkFreq = (float)(60.0 / beatAvg);
        else
          ledBlinkFreq = 0;
        ledcWriteTone(0, ledBlinkFreq);
      }
    }

    long irvalue2 = particleSensor.getIR();

    if (irvalue2 < 50000) {
      Serial.print("No finger detected");
      //---------------------------------------Firebase set function------------------------------------------
      if (Firebase.ready() && signupOK && (millis() - sendDataPrevMillis1 > 3000 || sendDataPrevMillis1 == 0)) {
        sendDataPrevMillis1 = millis();
        //Store and log data on firebase for historical viewing
        //        objectCelcius = 0;
        //        beatAvg = 0;
        //        sp02Avg = 0;
        json.set(tempPath.c_str(), "No finger detected");
        json.set(bpmPath.c_str(), "No finger detected");
        json.set(oxygenPath.c_str(), "No finger detected");
        json.set(timePath, String(timeStamp));

        Serial.printf("Set json... %s\n", Firebase.RTDB.setJSON(&fbdo, syncPath.c_str(), &json) ? "ok" : fbdo.errorReason().c_str());
        json.clear();
      }
      //------------------------------------------------------------------------------------------------------
    }
    else {
      //After gathering 25 new samples recalculate HR and SP02
      maxim_heart_rate_and_oxygen_saturation(irBuffer, bufferLength, redBuffer, &spo2, &validSPO2, &heartRate, &validHeartRate);

      Serial.print(beatAvg, DEC);

      Serial.print(F("\t HRvalid="));
      Serial.print(validHeartRate, DEC);

      Serial.print(F("\t SPO2="));
      Serial.print( sp02Avg , DEC);

      Serial.print(F("\t SPO2Valid="));
      Serial.println(validSPO2, DEC);

      //Calculates average SPO2
      if (validSPO2 == 1 && spo2 < 100 && spo2 > 0)
      {
        sp02Avg = (sp02Avg + spo2) / 2;
      }
      else
      {
        spo2 = 0;
        sp02Avg = (sp02Avg + spo2) / 2;;
      }

      //---------------------------------------Firebase set function------------------------------------------
      if (Firebase.ready() && signupOK && (millis() - sendDataPrevMillis1 > 3000 || sendDataPrevMillis1 == 0)) {
        sendDataPrevMillis1 = millis();

        objectCelcius = mlx.readObjectTempC();
        //time functions
        struct tm timeinfo;
        if (!getLocalTime(&timeinfo)) {
          Serial.println("Failed to obtain time");
        }
        strftime(timeStamp, 30, "%Y/%m/%d %r", &timeinfo);
        Serial.print ("Time: ");
        Serial.print (timeStamp);

        //Store and log data on firebase for historical viewing
        json.set(tempPath.c_str(), String(objectCelcius));
        json.set(bpmPath.c_str(), String(beatAvg));
        json.set(oxygenPath.c_str(), String(sp02Avg));
        json.set(timePath, String(timeStamp));

        Serial.printf("Set json... %s\n", Firebase.RTDB.setJSON(&fbdo, syncPath.c_str(), &json) ? "ok" : fbdo.errorReason().c_str());
        json.clear();
      }
      //------------------------------------------------------------------------------------------------------

      //---------------------------------------Firebase push function-----------------------------------------
      if (Firebase.ready() && signupOK && (millis() - sendDataPrevMillis2 > 10000 || sendDataPrevMillis2 == 0)) {
        sendDataPrevMillis2 = millis();

        objectCelcius = mlx.readObjectTempC();
        //time functions
        struct tm timeinfo;
        if (!getLocalTime(&timeinfo)) {
          Serial.println("Failed to obtain time");
        }
        strftime(timeStamp, 30, "%Y/%m/%d %r", &timeinfo);
        Serial.print ("Time: ");
        Serial.print (timeStamp);

        //Store and log data on firebase for historical viewing
        json.set(tempPath.c_str(), String(objectCelcius));
        json.set(bpmPath.c_str(), String(beatAvg));
        json.set(oxygenPath.c_str(), String(sp02Avg));
        json.set(timePath, String(timeStamp));

        Serial.printf("Push json... %s\n", Firebase.RTDB.pushJSON(&fbdo, storePath.c_str(), &json) ? "ok" : fbdo.errorReason().c_str());
        json.clear();
      }
      //------------------------------------------------------------------------------------------------------
    }
  }
}
